# Тестовое задание в авито на стажера осень 2025 
## Сервис назначения ревьюеров для Pull Request’ов

### В данной версии решены все базовые задачи без дополнительных

роуты находятся

Роуты задания:

/v1/api/team/add
/v1/api/team/get
/v1/api/users/setIsActive
/v1/api/users/getReview
/v1/api/pullRequest/create
/v1/api/pullRequest/merge
/v1/api/pullRequest/reassign

/v1/api/health - вспомогательный роут, чтобы понять, что бэк поднят

дефолтный хост бэка: 127.0.0.1:8080

по идее все подниматься должно с 
```
docker-compose up
```

также есть dev окружение

```
docker-compose -f docker-compose.dev.yml up
```

при запуске бэка миграции должны автоматически накатиться, также в миграциях уже есть готовые тестовые сущности 

также должен создаться env из example.env т.к. чувствительных данных нет, то он просто берет настройки из example
понятно, что в настоящих условиях в .env будут храниться чувствительные данные

чтобы работать только с БД, т.к. я работаю с винды, мне удобнее было так сделать.

также в папке postman есть коллекция тестовых запросов, делал для себя, но т.к. я не знаю как проводиться проверка, может пригодится:)

## Ход решения:

Честно говоря мне как бывшему phpшнику и немного node.jsнику было немного непривычно делать это задание,
потому что я приывк к более строгой архитектуре фреймворков и я потратил день или два, 
чтобы посмотреть исходники авитовских опенсорс решений и просто опенсорс решений
и понял, что четкой единой архитектуры по сути нет засчет своей простоты на GO принято по сути просто следовать шаблону
по типу [golang-standards/project-layout](https://github.com/golang-standards/project-layout) 
Это не первый мой го проект, но до этого я пользовался более простым средствами и менее организованным кодом, 
юзал ормки и т.д. Посмотрев рекомендации стажерам я решил, что стоит написать все через конструктор sql запросов 
squirrel, а не через готовые орм 

Архитектура примерно так выглядит: internal/cmd/app/main входная точка, internal/app/app инциализация всего бэка 
изначально хотел сделать чет вроде di контейнера pkg/ServiceDependencies вроде это называется manual di, но в последствии
код поменялся и по сути в данном моменте он избыточен, но на всякий случай оставил.
pkg/db все что связано с инциализирует бд и запускает миграции и также в migrations миграции 
в internal/config логика связанная с загрузкой переменных окружения из .env
Основная архитектура заключена в том что есть handlers по сути контроллеры, которые непосредственно работают с запросами
потом они передают это в сервисный слой usecases, где заключена бизнес логика, а в свою очередь сервис работает с repository
где происходит логика с сущностями из бд. Не уверен, что это лучшее решение, но в целом вроде как расширяемо, читаемо, гибко, 
нет сильных зависимостей между разными уровнями логики. Хотел сделать подобие ddd, наверное что-то даже получилось.
в ходе решения сильно изменились сущности, довольно поздно заметил по спецификации, что айдишники должны быть string
и сделал миграции и переписал часть кода, чтобы айди были не автоинкрементными интами, а string


## Решения, которые принял
Вынес статус пулреквеста в отдельную таблицу, чтобы была расширяемость.
Т.к. в гитхабе например может быть статус rejected условно, хардкодить энумом на лишь два статуса неудобно

Не увидел в тз ничего про авторизацию и создание пользователей, т.к. четко сказано, что "вольны принимать решения самостоятельно", то 
не стал добавлять авторизацию по JWT токену, но т.к. я использую GIN, то в гипотетическом расширении проекта 
будет легко её настроить через middleware на существующие эндпоинты

Нам требуется сделать сущность для комманд, сначала я думал завести вспомогательную таблицу team_members
чтобы можно было сделать многие ко многим. Но в тз насчет этого тоже не написано, что юзер обязательно должен быть в нескольких коммандах
я сначала думал про аналогию с организацией на гитхабе, но т.к. в тз ничего про это не указано, то будем считать, что юзер может быть закреплен только за одной коммандой
